---
layout:     post
title:      Android中常见的设计模式
subtitle:   Android
date:       2019-09-18
author:     wushiqian
header-img: img/post-bg-temple.jpg
catalog: true
tags:
    - Android
    - 设计模式
---

# 设计模式

## 设计模式六大原则

* 单一职责原则
* 开放封闭原则
* 里氏替换原则
* 依赖倒置原则
* 迪米特原则
* 接口隔离原则

## 设计模式分类

GoF提出的设计模式总共有23种，根据目的准则分类，分为三大类

* 创建型设计模式
* 结构型设计模式
* 行为型设计模式

## 创建型设计模式

### 单例模式

### 简单工厂模式

### 工厂方法模式

日常开发的BaseActivity抽象工厂模式：

定义：为创建一组相关或者是相互依赖的对象提供一个接口，而不需要指定它们的具体类。

主题切换的应用：

比如我们的应用中有两套主题，分别为亮色主题LightTheme和暗色主题DarkTheme，这两种主题我们可以通过一个抽象的类或接口来定义，而在对应主题下我们又有各类不同的UI元素，比如Button、TextView、Dialog、ActionBar等，这些UI元素都会分别对应不同的主题，这些UI元素我们也可以通过抽象的类或接口定义，抽象的主题、具体的主题、抽象的UI元素和具体的UI元素之间的关系就是抽象工厂模式最好的体现。

优点：

- 分离接口与实现，面向接口编程，使其从具体的产品实现中解耦，同时基于接口与实现的分离，使抽象该工厂方法模式在切换产品类时更加灵活、容易。

缺点：

- 类文件的爆炸性增加。
- 新的产品类不易扩展。

### 建造者模式

AlertDialog、Notification源码中使用了Bulider（建造者）模式完成参数的初始化：

在AlertDialog的Builder模式中并没有看到Direcotr角色的出现，其实在很多场景中，Android并没有完全按照GOF的经典设计模式来实现，而是做了一些修改，使得这个模式更易于使用。这个的AlertDialog.Builder同时扮演了上下文中提到的builder、ConcreteBuilder、Director的角色，简化了Builder模式的设计。当模块比较稳定，不存在一些变化时，可以在经典模式实现的基础上做出一些精简，而不是照搬GOF上的经典实现，更不要生搬硬套，使程序失去架构之美。

定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。即将配置从目标类中隔离出来，避免过多的setter方法。

优点：

- 1、良好的封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节。
- 2、建造者独立，容易扩展。

缺点：

- 会产生多余的Builder对象以及Director对象，消耗内存。

### 简单工厂、工厂方法、抽象工厂、Builder模式的区别？

- 简单工厂模式：一个工厂方法创建不同类型的对象。
- 工厂方法模式：一个具体的工厂类负责创建一个具体对象类型。
- 抽象工厂模式：一个具体的工厂类负责创建一系列相关的对象。
- Builder模式：对象的构建与表示分离，它更注重对象的创建过程。

## 结构型设计模式

### 代理模式

AIDL代理模式：

定义：为其他对象提供一种代理以控制对这个对象的访问。

静态代理：代码运行前代理类的class编译文件就已经存在。

动态代理：通过反射动态地生成代理者的对象。代理谁将会在执行阶段决定。将原来代理类所做的工作由InvocationHandler来处理。

使用场景：

- 当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。

缺点：

- 对类的增加。

### 装饰模式

### 外观模式

Context/ContextImpl外观模式：

要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行，门面模式提供一个高层次的接口，使得子系统更易于使用。

使用场景：

- 为一个复杂子系统提供一个简单接口。

优点：

- 对客户程序隐藏子系统细节，因而减少了客户对于子系统的耦合，能够拥抱变化。
- 外观类对子系统的接口封装，使得系统更易用使用。

缺点：

- 外观类接口膨胀。
- 外观类没有遵循开闭原则，当业务出现变更时，可能需要直接修改外观类。

### 享元模式

### 装饰模式和代理模式有哪些区别 ？与桥接模式相比呢？

- 1、装饰模式是以客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。
- 2、装饰模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增加。
- 3、桥接模式的作用于代理、装饰截然不同，它主要是为了应对某个类族有多个变化维度导致子类类型急剧增多的场景。通过桥接模式将多个变化维度隔离开，使得它们可以独立地变化，最后通过组合使它们应对多维变化，减少子类的数量和复杂度。

### 责任链模式

Okhttp内部使用了责任链模式来完成每个Interceptor拦截器的调用：

定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。

ViewGroup事件传递的递归调用就类似一条责任链，一旦其寻找到责任者，那么将由责任者持有并消费掉该次事件，具体体现在View的onTouchEvent方法中返回值的设置，如果onTouchEvent返回false，那么意味着当前View不会是该次事件的责任人，将不会对其持有；如果为true则相反，此时View会持有该事件并不再向下传递。

优点：

将请求者和处理者关系解耦，提供代码的灵活性。

缺点：

对链中请求处理者的遍历中，如果处理者太多，那么遍历必定会影响性能，特别是在一些递归调用中，要慎重。

## 行为型设计模式

### 策略模式

### 模板方法模式

### 观察者模式

RxJava的观察者模式：

定义：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

ListView/RecyclerView的Adapter的notifyDataSetChanged方法、广播、事件总线机制。

观察者模式主要的作用就是对象解耦，将观察者与被观察者完全隔离，只依赖于Observer和Observable抽象。

优点：

- 观察者和被观察者之间是抽象耦合，应对业务变化。
- 增强系统灵活性、可扩展性。

缺点：

- 在Java中消息的通知默认是顺序执行，一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般考虑采用异步的方式。

## 小结

参考：《Android源码设计模式解析与实战（第二部）》、《大话设计模式》、《Android进阶之光》