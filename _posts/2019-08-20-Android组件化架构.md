---
layout:     post
title:      Android组件化架构
subtitle:   Android
date:       2019-08-20
author:     wushiqian
header-img: img/post-bg-temple.jpg
catalog: true
tags:
    - Android
    - 架构
---

# 组件化

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5sj9bh9xzj30ig0pgdge.jpg)

app：壳工程；
module1：组件1；
module2：组件2；
resource：专门放资源文件；
router：路由，所有页面请求都由它中转；
common：第三方库，公用工具、自定义 View等。

## 为什么要项目组件化
随着APP版本不断的迭代，新功能的不断增加，业务也会变的越来越复杂，APP业务模块的数量有可能还会继续增加，而且每个模块的代码也变的越来越多，这样发展下去单一工程下的APP架构势必会影响开发效率，增加项目的维护成本，每个工程师都要熟悉如此之多的代码，将很难进行多人协作开发，而且Android项目在编译代码的时候电脑会非常卡，又因为单一工程下代码耦合严重，每修改一处代码后都要重新编译打包测试，导致非常耗时，最重要的是这样的代码想要做单元测试根本无从下手，所以必须要有更灵活的架构代替过去单一的工程架构。

## 全局设置 Gradle

如果有很多项目，可以设置全局来统一管理版本号或依赖库，这样就不用一个个去改了，根目录下 build.gradle 添加：

```
def androidSupportVersion = '27.1.0'
ext {
    //编译的 SDK 版本，如API20
    compileSdkVersion = 27
    //构建工具的版本，其中包括了打包工具aapt、dx等,如API20对应的build-tool的版本就是20.0.0
    //buildToolsVersion = "26.0.0"
    //兼容的最低 SDK 版本
    minSdkVersion = 14
    //向前兼容，保存新旧两种逻辑，并通过 if-else 方法来判断执行哪种逻辑
    targetSdkVersion = 27
    appcompatV7 = "com.android.support:appcompat-v7:$androidSupportVersion"
    constraintLayout = 'com.android.support.constraint:constraint-layout:1.0.2'
}
```

其中module/build.gradle：

```
android {
    compileSdkVersion rootProject.ext.compileSdkVersion
    buildToolsVersion rootProject.ext.buildToolsVersion
    //……
}
```

## 资源名重名

每个 module 都有 appname，为了不让资源名重名，可以在每个组件的 build.gradle 中增加 resourcePrefix “xxx“，固定每个组件的资源前缀。但是 resourcePrefix 这个值只能限定 xml 里面的资源，并不能限定图片资源，所有图片资源仍然需要你手动去修改资源名。

## 组件单独调试
application 与 library 切换
module1 在开发阶段应该 application，等 release 后才是 library，这里可以设置一个变量控制下，在根项目 gradle.properties 加入：

# 组件单独调试

application 与 library 切换
module1 在开发阶段应该 application，等 release 后才是 library，这里可以设置一个变量控制下，在根项目 gradle.properties 加入：

```
# 开关，true 可以，false 不可以，需要点击 "Sync Project"。
isDebug=false
```

module1/build.gradle：

```
if (isDebug.toBoolean()) {
    apply plugin: 'com.android.application'
} else {
    apply plugin: 'com.android.library'
}
android {
    //……    
}
```

applicationId
开发阶段，module1 还必须有个 applicationId：

```
android {
     //……
    defaultConfig {
        // 作为library时不能有applicationId,只有作为一个独立应用时才能够如下设置
        if (isDebug.toBoolean()){
            applicationId "com.matrix.module1"
        }
        //……
        }
}
```

## 入口类

到这里还不行，还得有 AndroidManifest 设置入口类，release 后这个 AndroidManifest 不需要打包进去，新建文件 debug，然后在 build.gradle 指定路径：

```
android {
    //……  
    sourceSets {
        main {
            if (isDebug.toBoolean()) {
                manifest.srcFile 'src/main/debug/AndroidManifest.xml'
            } else {
                manifest.srcFile 'src/main/release/AndroidManifest.xml'
                java {
                    //release 时 debug 目录下文件不需要合并到主工程
                    exclude 'debug/**'
                }
            }
        }
    }
}
```
另外，module 可能会需要使用到自定义的 Application，release 同样也不需要打包进去，不然合并会有冲突。

## 组件间通信
组件间通信包括两个场景：（1）UI 跳转；（2）调用组件某个类的某个方法。
这里涉及路由，何为路由，就是页面请求，都交给它处理。网上有很多路由库，我这里选的是阿里的 ARouter，ARouter 能解决上面的问题。

## Arouter

A framework for assisting in the renovation of Android componentization (帮助 Android App 进行组件化改造的路由框架)

[官方文档](https://github.com/alibaba/ARouter/blob/master/README_CN.md)

支持直接解析标准URL进行跳转，并自动注入参数到目标页面中
支持多模块工程使用
支持添加多个拦截器，自定义拦截顺序
支持依赖注入，可单独作为依赖注入框架使用
支持InstantRun
支持MultiDex(Google方案)

### 使用方式

1.添加依赖和配置

```
android {
    defaultConfig {
        ...
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [AROUTER_MODULE_NAME: project.getName()]
            }
        }
    }
}

dependencies {
    // 替换成最新版本, 需要注意的是api
    // 要与compiler匹配使用，均使用最新版可以保证兼容
    compile 'com.alibaba:arouter-api:x.x.x'
    annotationProcessor 'com.alibaba:arouter-compiler:x.x.x'
    ...
}
// 旧版本gradle插件(< 2.2)，可以使用apt插件，配置方法见文末'其他#4'
// Kotlin配置参考文末'其他#5'
```

2.添加注解
```
// 在支持路由的页面上添加注解(必选)
// 这里的路径需要注意的是至少需要有两级，/xx/xx
@Route(path = "/test/activity")
public class YourActivity extend Activity {
    ...
}
```

3.初始化SDk

```
if (isDebug()) {           // 这两行必须写在init之前，否则这些配置在init过程中将无效
    ARouter.openLog();     // 打印日志
    ARouter.openDebug();   // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)
}
ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化
```

4.发起路由操作

```
// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)
ARouter.getInstance().build("/test/activity").navigation();

// 2. 跳转并携带参数
ARouter.getInstance().build("/test/1")
            .withLong("key1", 666L)
            .withString("key3", "888")
            .withObject("key4", new Test("Jack", "Rose"))
            .navigation();
           
``` 

5.添加混淆规则(如果使用了Proguard)

```
-keep public class com.alibaba.android.arouter.routes.**{*;}
-keep public class com.alibaba.android.arouter.facade.**{*;}
-keep class * implements com.alibaba.android.arouter.facade.template.ISyringe{*;}
```

6.使用 Gradle 插件实现路由表的自动加载 (可选)

```
apply plugin: 'com.alibaba.arouter'

buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath "com.alibaba:arouter-register:?"
    }
}
```
可选使用，通过 ARouter 提供的注册插件进行路由表的自动加载(power by AutoRegister)， 默认通过扫描 dex 的方式 进行加载通过 gradle 插件进行自动注册可以缩短初始化时间解决应用加固导致无法直接访问 dex 文件，初始化失败的问题，需要注意的是，该插件必须搭配 api 1.3.0 以上版本使用！

## ARouter Helper

在 Android Studio 插件市场中搜索 ARouter Helper, 或者直接下载文档上方 最新版本 中列出的 arouter-idea-plugin zip 安装包手动安装，安装后 插件无任何设置，可以在跳转代码的行首找到一个图标 (navigation) 点击该图标，即可跳转到标识了代码中路径的目标类


## 组件化AndroidManifest

## 组件化Application

## 动态创建

### 反射

### 反射简化jOOR

### 动态创建Fragment

## 组件化权限管理

## 组件化的静态变量

## 组件化资源冲突

## 参考资料

《Android组件化架构》

[ArmsComponent](https://github.com/JessYanCoding/ArmsComponent)

[组件化在项目中的使用姿势](https://www.jianshu.com/p/ed845d796710)

[Android组件化实践项目分享](https://juejin.im/post/5c7f85b3e51d45721073f966)

[用玩Android学习android - 组件化](https://github.com/chinalwb/modularized_wan_android)