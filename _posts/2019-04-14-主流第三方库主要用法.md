---
layout:     post
title:      主流第三方库的使用方法
subtitle:   RxJava、Retrofit、Okhttp、EventBus、Dagger、Butter Knife
date:       2019-04-14
author:     wushiqian
header-img: img/post-bg-digital-native.jpg
catalog: true
tags:
    - Android
---

# 主流第三方库的使用方法

主要写主流第三方库的简单配置和使用方法。

## Butter knife

### 加入到项目的方法

Gradle项目（现在Android应该都是Gradle了吧，在build.gradle文件中）

```
implementation 'com.jakewharton:butterknife:7.0.1'
```

另外，还需要下面两个配置：

//支持lint warning 检查机制

```
lintOptions {
  disable 'InvalidPackage'
}

//为什么加入这个呢？防止冲突，比如我同时用了dagger-compiler就会报错，说下面这个`Processor`重复了
packagingOptions {
  exclude 'META-INF/services/javax.annotation.processing.Processor'
}
```
这样加入了还没有完，我们还要在Proguard中加入下面这些代码(为什么呢？Proguard的原理大家如果懂的话就知道了，Butterknife的使用和生成的一些类都是动态的，而ProGuard这样的工具可能判定这些类没有被使用而移除他们，所以要在他的配置文件下面做下面的配置)：
`
	-keep class butterknife.** { *; }
	
	-dontwarn butterknife.internal.**
	-keep class **$$ViewBinder { *; }
	-keepclasseswithmembernames class * {
   	 	@butterknife.* <fields>;
	}
	-keepclasseswithmembernames class * {
    	@butterknife.* <methods>;
	}
`

### 最简单的用法

最简单的肯定是自动关联View了，以前我们都是样板式的代码：

```
  private Button btn;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        btn=(Button)findViewById(R.id.btn);
        btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Toast.makeText(MainActivity.this, "Btn Clicked", Toast.LENGTH_SHORT).show();
            }
        });
    }
```
后来有了ButterKnife就简单了，如下：

```
class ExampleActivity extends Activity {
  @Bind(R.id.title) Button btn;
  @Override public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    ButterKnife.bind(this);
    // TODO Use fields...
  }
}
```
没有一堆的findViewById和强制转换是不是清爽多了呢？ 
而且，即使这些代码，都可以通过Android Studio的插件Android ButterKnife Zelezny帮你完成了。

ButterKnife可不是通过反射实现了，而是在编译的时候生成的代码，和我们自己写的其实原理一样，比如上面的Button的绑定的实现就类似下面的方法：

```
public void bind(ExampleActivity activity) {
    activity.btn = (android.widget.Button) activity.findViewById(2130968578); 
}
```
ButterKnife以前绑定的代码是@InjectView注解和inject方法，现在改了名字感觉更容易理解了，基本原理没变。

另外，大家关心@Bind注解对于绑定的成员变量有没有要求呢？其实是有的，如果你试着将它的限定符改为private，在编译的时候就会报错如下： 
```
Error:(21, 20) 错误: @Bind fields must not be private or static. ...
```
也就是你的成员变量不能是private 或者static修饰了。

### 更多的绑定

#### 绑定资源
```
class ExampleActivity extends Activity {
  @BindString(R.string.title) String title;
  @BindDrawable(R.drawable.graphic) Drawable graphic;
  @BindColor(R.color.red) int red; // int or ColorStateList field
  @BindDimen(R.dimen.spacer) Float spacer; // int (for pixel size) or float (for exact value) field
  // ...
}
```
绑定其他的资源类似，应该不需要一一列举了吧
不过有时候资源不需要搞成成员变量吧？自己选择吧

#### 非Activity的绑定
比如说Fragment中（得到View，然后bind方法传入这个View的实例）：

```
public class FancyFragment extends Fragment {
  @Bind(R.id.button1) Button button1;
  @Bind(R.id.button2) Button button2;
  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fancy_fragment, container, false);
    ButterKnife.bind(this, view);
    // TODO Use fields...
    return view;
  }
}
```

#### 在Adapter中的用法
经常会在Adapter中使用ViewHolder，其实你也可以在ViewHolder中使用ButterKnife： 
在ViewHolder的构造函数中调用bind，然后成员变量同样的使用@Bind注解。其实这几种绑定原理都一样，就是我们前面编译后的代码那样的方式。

```
public class MyAdapter extends BaseAdapter {
  @Override public View getView(int position, View view, ViewGroup parent) {
    ViewHolder holder;
    if (view != null) {
      holder = (ViewHolder) view.getTag();
    } else {
      view = inflater.inflate(R.layout.whatever, parent, false);
      holder = new ViewHolder(view);
      view.setTag(holder);
    }
    holder.name.setText("John Doe");
    // etc...
    return view;
  }
  static class ViewHolder {
    @Bind(R.id.title) TextView name;
    @Bind(R.id.job_title) TextView jobTitle;
    public ViewHolder(View view) {
      ButterKnife.bind(this, view);
    }
  }
}
```
ButterKnife.bind()还有其他的一些API，可以自己关注一下，直接看源码的注释很容易理解了。

#### View List批量操作
如果我们有一系列的View放到了一个List里面，就可以进行批量操作了：批量绑定，批量设置属性等。

```
//批量绑定
@Bind({ R.id.first_name, R.id.middle_name, R.id.last_name })
List<EditText> nameViews;
//批量设置
ButterKnife.apply(nameViews, DISABLE);
ButterKnife.apply(nameViews, ENABLED, false);
```
其中，DIABLE,ENABLED是我们定义的两个对象，一个是Action，负责执行操作，一个是Setter，负责将值设置为第三个参数：

```
static final ButterKnife.Action<View> DISABLE = new ButterKnife.Action<View>() {
  @Override public void apply(View view, int index) {
    view.setEnabled(false);
  }
};
static final ButterKnife.Setter<View, Boolean> ENABLED = new ButterKnife.Setter<View, Boolean>() {
  @Override public void set(View view, Boolean value, int index) {
    view.setEnabled(value);
  }
};
```
也就是第一个apply将所有的nameViews中的View对象设置为disabled，第二个apply将所有的对象的enable属性设置为false（第三个参数）

另外，我们可以直接对属性进行设置，而不需要编写Action和Setter，例如：

```
ButterKnife.apply(nameViews, View.ALPHA, 0.0f);
```

#### 绑定监听器
ButterKnife还有一个比较常用的功能就是类似@OnClick等的绑定监听器的方法，Android中需要大量的监听器监听用户的操作。示例如下：

```
@OnClick(R.id.submit)
public void submit(View view) {
  // TODO submit data to server...
}
```
如果不需要绑定的对象，不写也可以：

```
@OnClick(R.id.submit)
public void submit() {
  // TODO submit data to server...
}
```
而且，这里可以直接将绑定的实例转换成实际的对象：

```
@OnClick(R.id.submit)
public void sayHi(Button button) {
  button.setText("Hello!");
}
```
另外，多个View也可以绑定到一个处理方法上：

```
@OnClick({ R.id.door1, R.id.door2, R.id.door3 })
public void pickDoor(DoorView door) {
  if (door.hasPrizeBehind()) {
    Toast.makeText(this, "You win!", LENGTH_SHORT).show();
  } else {
    Toast.makeText(this, "Try again", LENGTH_SHORT).show();
  }
}
```
如果是自定义的View，可以直接绑定到他自己的处理方法上而不需要指定ID

```
public class FancyButton extends Button {
  @OnClick
  public void onClick() {
    // TODO do something!
  }
}
```
这样，用户点击FancyButton时就会触发该方法。

#### 绑定重置
我们可能需要在Fragment销毁的时候将绑定的View全部设置为null，ButterKnife提供了一个unbind方法自动执行这个操作。

```
public class FancyFragment extends Fragment {
  @Bind(R.id.button1) Button button1;
  @Bind(R.id.button2) Button button2;
  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fancy_fragment, container, false);
    ButterKnife.bind(this, view);
    // TODO Use fields...
    return view;
  }
  @Override public void onDestroyView() {
    super.onDestroyView();
    ButterKnife.unbind(this);
  }
}
```

#### 可选的绑定
如果你给一个绑定添加了一个@Nullable注解，即使对应的资源id不存在也不会报错。有时候我们不能保证这个id一定存在，或者有特殊的需求的时候可以使用

```
@Nullable @Bind(R.id.might_not_be_there) TextView mightNotBeThere;
@Nullable @OnClick(R.id.maybe_missing) void onMaybeMissingClicked() {
  // TODO ...
}
```

#### 多方法监听
例如ListView的设置onItemOnItemSelected的SelectedListener接口有两个回调方法，一个是onItemSelected，一个是onNothingSelected，这时候，我们可以设置两个注解来分别处理这两个回调方法：

```
@OnItemSelected(R.id.list_view)
void onItemSelected(int position) {
  // TODO ...
}
@OnItemSelected(value = R.id.maybe_missing, callback = NOTHING_SELECTED)
void onNothingSelected() {
  // TODO ...
}
```

## EventBus

EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现。

### 优点

1.	简化组件间的通信
（1）.对发送和接受事件解耦
（2）.可以在Activity，Fragment，和后台线程间执行
（3）.避免了复杂的和容易出错的依赖和生命周期问题
2.	让你的代码更简洁
3.	更快
4.	更轻量（jar包小于50K）
5.	实践证明已经有一亿多的APP中集成了EventBus
6.	拥有先进的功能比如线程分发，用户优先级等等

### 为什么要使用EventBus
1.简化子线程和主线程之间或两个子线程之间的消息传递
通常我们都会在一个线程中做一些耗时操作得到数据之后需要发送到另一个线程去处理数据（这个线程可以是主线程去更新UI，或子线程继续处理接下来的任务）。这些通信都需要用到Handler。我们需要定义Handler，并重写handleMessage方法去处理数据，在使用处定义Message对象携带数据并发送到指定的Handler中
2.代替BroadcastReceiver/Intent
不同于安卓的BroadcastReceiver/Intent，EventBus就是普通的java类，它提供很简单易用的API调用。EventBus适用于更多的场景，并不需要你麻烦的设置Intent，设置携带数据，然后从Intent中取出数据，或者定义广播和广播接受者。同时，EventBus的开销会低，对于输出传送方和接收方没有那么高的耦合。
3.简化数据传输
比如：（1）在一个Activity中横向同时加载两个Fragment，左边的ragment是列表，右边的Fragment是详情展示。这时候涉及到Activity和Fragment，两个Fragment之间的通信（2）当使用startService启动一个Service时，你需要和Service相互通信时（3）有些场景需要使用接口处理问题时（4）在应用程序运行时可能有多个界面，多处都需要使用到一个数据时，这个数据只是需要临时存储，并不需要落地时。

### 加入到项目的方法
添加依赖库：

implementation 'de.greenrobot:eventbus:3.0.0-beta1'

### 基本用法

#### 定义一个事件
需要定义的这个事件其实就是一个普通的Java Object（POJO）,并没有特殊的要求
```
 public class MessageEvent {
      public final String message;

      public MessageEvent(String message) {
          this.message = message;
      }
    }

#### 注册
举个例子，你需要在一个activity中注册eventbus事件，然后定义接收方法，这和Android的广播机制很像，你需要首先注册广播，然后需要编写内部类，实现接收广播，然后操作UI,在EventBus中，你同样需要这么做。

```
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    EventBus.getDefault().register(this);

}
@Override
protected void onDestroy() {
    super.onDestroy();
    EventBus.getDefault().unregister(this);
}
```
#### 订阅者
类似广播，但是有别于2.4版本，你不必再去约定OnEvent方法开头了（看不懂没关系）：

```
@Subscribe(threadMode = ThreadMode.MainThread)
public void helloEventBus(String message){
    mText.setText(message);
}
```

该操作很简单，定义了一个hello方法，需要传入String参数，在其中操作UI操作，注意：
我们添加了注解@Subscribe，其含义为订阅者，在其内传入了threadMode，我们定义为ThreadMode.MainThread，其含义为该方法在UI线程完成，这样你就不要担心抛出异常啦。是不是很简单？

#### 发布者
既然你在某个地方订阅了内容，当然就会在某个地方发布消息。举个例子，你的这个activity需要http请求，而http请求你肯定是在异步线程中操作，其返回结果后，你可以这么写：

```
String json="";
EventBus.getDefault().post(json);
```

这样就OK了，你可以试下能否正常运行了！

### 线程分发和线程模型

Event可以为你处理线程：事件可以被发布到与发布线程不同的线程中。
一般用法是处理UI，在安卓中UI的处理需要在主线程中完成，其他处理比如网络请求，耗时操作不能在主线程中处理。EventBus帮助你处理这些任务并且同步到UI线程（不用深入研究线程转换，使用AsyncTask等等）
   在EvenyBus中，在将要调用事件处理方法onEvent时可以使用一个ThreadMode去定义这个方法调用的线程。
ThreadMode有四种：
PostThread，MainThread，BackgroundThread，Async.
PostThread:订阅者将会被调用在与发布线程同样的线程中。这是默认的，事件的分发意味着最小的开销，因为这种模式避免了线程切换。对于简单任务来说这是被推荐的用法。使用这个mode需要快速返回结果，避免锁住主线程，因为他可能在主线程执行。

```
// Called in the same thread (default)
    public void onEvent(MessageEvent event) {
        log(event.message);
    }
```

**MainThread：**订阅者将被回调在安卓的主线程中。如果发布线程是主线程那事件的处理会马上被执行。同样使用这个mode需要快速返回结果，避免锁住主线程。

```
// Called in Android UI's main thread
    public void onEventMainThread(MessageEvent           event)  {
        textField.setText(event.message);
     }
```
**BackgroundThread：**订阅者将会被回调在子线程中。如果发布线程不是主线程，事件处理会马上被执行在发布线程中。如果发布线程是主线程，EventBus会使用一个单独的子线程顺序处理事件。虽然是子线程，但是也需要尽快返回结果，避免锁住线程。

```
// Called in the background thread
public void onEventBackgroundThread
(MessageEvent event){
        saveToDisk(event.message);
    }
```
**Async：**事件处理方法会在一个单独的线程中调用。这个线程永远独立与发布线程和主线程。如果需要处理耗时任务时事件处理方法应该使用这个mode。比如网络请求。避免在短时间内引发大量的长时间运行的异步任务EventBus使用线程池有效的控制线程数并重用线程

```
// Called in a separate thread
    public void onEventAsync(MessageEvent event){
        backend.send(event.message);
    }
    
```

*EventBus负责在适当的线程中调用onEvent方法取决于方法的后缀。*
    
### 取消事件分发

可以在订阅者的事件处理方法（onEvent）中调用cancelEventDelivery(Object event)这个方法去取消事件的分发,任何进一步的事件分发都会被取消，后续的订阅者不会再收到此类事件。

```
// Called in the same thread (default)
    public void onEvent(MessageEvent event){
        // Process the event 
        ...
        EventBus.getDefault()
.cancelEventDelivery(event) ;
    }
``` 
注意：*事件通常被高优先级的订阅者取消。取消只能在ThreadMode为PostThread时，也就是onEvent方法中取消。*

### 粘性的事件

一些event携带的消息是在event被发布后。有这些场景：你需要通过一个event去做初始化，或如果你有传感器或一些本地数据并且你想要保存最近的值。你可以使用粘性事件去代替你自己的缓存。EventBus会把最后一个确定类型的粘性事件保存到内存中。粘性事件可以被订阅者接收或者根据事件类型去查询获取。因此不需要特定的逻辑去验证可用数据。

```
    EventBus.getDefault().postSticky(new MessageEvent("Hello everyone!"));
```

复制代码这段代码之后，一个新的Activity启动了，可以使用registerSticky去注册EventBus，这个注册操作会马上获得之前的发布的事件，在onEvent方法中执行。

```
 @Override
    public void onStart() {
        super.onStart();
        EventBus.getDefault().registerSticky(this);
    }

    public void onEventMainThread(MessageEvent event) {
        textField.setText(event.message);
    }

    @Override
    public void onStop() {
        EventBus.getDefault().unregister(this);
        super.onStop();
    }
复制代码也可以根据确定的类型去获取一个粘性事件
EventBus.getDefault().getStickyEvent(Class<?> eventType)
```

*注意：可以使用removeStickyEvent方法移除之前发布的粘性事件。可以通过事件对象或者事件的类去移除。也可以去构建一个自定义的事件。但是要记住一个类型的事件只有一个会被保存*

## RxJava